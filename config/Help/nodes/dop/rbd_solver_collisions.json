{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [34, 263], "text": ["The stack solver iterates over all objects looking for\n    ballistic collisions. Because resolving one collision may create\n    a collision elsewhere, this cannot be resolved in a single pass\n    with a local solution. "]}, {"indent": 4, "type": "para", "extent": [263, 404], "text": ["The stack solver will thus repeat the\n    collision resolution until either no collisions are found, or\n    this pass count is reached."]}, {"indent": 4, "type": "para", "extent": [404, 581], "text": ["Even if a collision is not fully resolved with these passes, it\n    will still be cleaned up in the Contact Pass. The main\n    difference is that it will become inelastic."]}], "indent": 0, "type": "dt", "extent": [16, 34], "text": ["Collision Passes"]}, {"body": [{"indent": 4, "type": "para", "extent": [597, 735], "text": ["The stack solver iterates over all objects, looking for cases\n    where resting contact requires an acceleration to be adjusted."]}, {"indent": 4, "type": "para", "extent": [735, 876], "text": ["Multiply stacked objects are common, so this often has\n    complicated interrelationships, so requires multiple passes to\n    converge."]}], "indent": 0, "type": "dt", "extent": [581, 597], "text": ["Contact Passes"]}, {"body": [{"indent": 4, "type": "para", "extent": [895, 1123], "text": ["Resting objects have a higher stability requirement than\n    bouncing objects. Thus, the object is not immediately brought to\n    a standstill, but slowed over multiple iterations to allow the\n    system to stabilize. "]}, {"indent": 4, "type": "para", "extent": [1123, 1199], "text": ["This is the number of steps to do this for\n    every contact pass."]}], "indent": 0, "type": "dt", "extent": [876, 895], "text": ["SubContact Passes"]}, {"body": [{"indent": 4, "type": "para", "extent": [1218, 1277], "text": ["These passes are very similar to Contact Passes. "]}, {"indent": 4, "type": "para", "extent": [1277, 1516], "text": ["The main\n    difference is that if a book were resting on a table, the table\n    would be assigned infinite mass in this pass. This prevents the\n    table from shifting into the ground, allowing the system to\n    converge faster."]}, {"indent": 4, "type": "para", "extent": [1516, 1773], "text": ["As a rule of thumb, set this to the expected maximum number\n    of stacked objects. If you plane to have ten tables stacked\n    on top of one another in a stable configuration, a value of\n    10 can help ensure that the stacking is fully resolved."]}, {"indent": 4, "type": "para", "extent": [1773, 1946], "text": ["If your objects come to rest appropriately, but then seem to\n    slowly start to sink through each other, increasing Shock\n    Propagation can be the right answer."]}], "indent": 0, "type": "dt", "extent": [1199, 1218], "text": ["Shock Propagation"]}, {"body": [{"indent": 4, "type": "para", "extent": [1968, 2127], "text": ["These passes are a final attempt to prevent any\n    interpenetration. Like Shock Propagation, it is attempted to\n    process objects from bottom up. "]}, {"indent": 4, "type": "para", "extent": [2127, 2323], "text": ["If a book is resting on a table\n    and is penetrating the table, the book will be moved to lie\n    outside of the table. This will be performed even if the book is\n    at rest on the table."]}, {"indent": 4, "type": "para", "extent": [2323, 2459], "text": ["The penetration recover repeated until there are no more\n    penetrations up to the maximum number provided by this\n    parameter."]}, {"indent": 4, "type": "para", "extent": [2459, 2749], "text": ["The SubContact Passes is used to slowly feather the objects\n    apart. Rather than immediately moving the book outside of the\n    table, it is done in over the given number of subcontact passes.\n    This is done to attempt to stabilize the process when\n    complicated overlaps occur."]}], "indent": 0, "type": "dt", "extent": [1946, 1968], "text": ["Resolve Penetrations"]}, {"body": [{"indent": 4, "type": "para", "extent": [2784, 3077], "text": ["Determines if changes in the point positions will be used in\n    collision resolution. Note that this is different from the\n    Inherit Velocity option of RBD State. This flag only governs if\n    velocity attributes are used for collisions, not for setting up\n    the initial velocities."]}, {"indent": 4, "type": "para", "extent": [3077, 3272], "text": ["When this is set, the object is inspected for any per point\n    velocity attribute. If present, it is assumed to be a local\n    deformation vector and is used to improve collision response."]}, {"indent": 4, "type": "para", "extent": [3272, 3551], "text": ["If no point velocities are present, the geometry is compared\n    between the two frames to manually calculate the per-point\n    velocity. Note that if your deformation is a function of $F you\n    may not get expected results as that is a step function, use $FF\n    instead."]}], "indent": 0, "type": "dt", "extent": [2749, 2784], "text": ["Use Point Velocity for Collisions"]}, {"body": [{"indent": 4, "type": "para", "extent": [3587, 3689], "text": ["Determines if changes to the volumetric representation will be\n    used in collision resolution."]}, {"indent": 4, "type": "para", "extent": [3689, 3941], "text": ["When this is set the volumetric representation is compared\n    between this frame and the previous frame. The difference is\n    used to compute a velocity of the surface\u2019s deformation. This\n    allows deforming objects to interact plausibly. "]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [3951, 4014], "text": ["This method can handle changing topologies, but cannot"]}], "indent": 4, "role": "item", "type": "note", "extent": [3941, 3951]}], "container": true, "role": "item_group", "type": "note_group"}, {"indent": 4, "type": "para", "extent": [4014, 4065], "text": ["discover tangential deformational velocities."]}], "indent": 0, "type": "dt", "extent": [3551, 3587], "text": ["Use Volume Velocity for Collisions"]}, {"body": [{"indent": 4, "type": "para", "extent": [4095, 4349], "text": ["When objects are resting on top of one another, they still receive impacts due to the force of gravity.  This option prevents these from being added to the glue impulse, making it easier to prevent things from falling apart under their own gravity."]}], "indent": 0, "type": "dt", "extent": [4065, 4095], "text": ["Glue Ignores Resting Objects"]}, {"body": [{"indent": 4, "type": "para", "extent": [4366, 4528], "text": ["During the RBD solving process, numerous impacts are calculated\n    between the RBD objects. These are normally not recorded in\n    order to save time. "]}, {"indent": 4, "type": "para", "extent": [4528, 4668], "text": ["If this is set, however, all such impacts\n    will be recorded by attaching an Impacts/RBDImpacts data to the\n    objects that collide."]}], "indent": 0, "type": "dt", "extent": [4349, 4366], "text": ["Add Impact Data"]}, {"body": [{"indent": 4, "type": "para", "extent": [4684, 4884], "text": ["In simulations with a large number of objects, it is helpful to\n    use various space partitioning schemes to reduce the work in\n    finding collisions. This option selects one of these schemes."]}, {"indent": 4, "type": "para", "extent": [4884, 4951], "text": ["None means that no attempt at spatial subdivision will occur."]}, {"indent": 4, "type": "para", "extent": [4951, 5156], "text": ["Sphere means the objects will be treated as spheres and trivial\n    intersection detection will be done with these spheres. This is\n    fast, but with long skinny objects could cause false positives."]}, {"indent": 4, "type": "para", "extent": [5156, 5345], "text": ["OBB means Oriented Bounding Boxes. While this provides a tight\n    bound on long skinny objects, building the spatial partitioning\n    tree is slow and will often exceed the benefits."]}], "indent": 0, "type": "dt", "extent": [4668, 4684], "text": ["Culling Method"]}, {"body": [{"indent": 4, "type": "para", "extent": [5370, 5480], "text": ["Controls whether and how Houdini groups similar points together\n    when it calculates point collisions."]}, {"indent": 4, "type": "para", "extent": [5480, 5740], "text": ["If you set this parameter to a value other than \"none\", Houdini\n    will treat similar points (that is, points within the distance\n    specified in the ", {"text": ["Contact grouping tolerance"], "type": "ui"}, " below) as a\n    single point for the purpose of calculating collisions."]}, {"indent": 4, "type": "para", "extent": [5740, 6066], "text": ["This is useful when you have an object such as a cube, where the\n    geometry points (the corners of the cube) are spaced far apart.\n    One corner might impact a ground plane first, then the cube\n    bounces and rotates so the opposite corner hits, which bounces\n    and rotates, causing jitter when the cube hits. "]}, {"indent": 4, "type": "para", "extent": [6066, 6256], "text": ["If you set the ", {"text": ["Contact Grouping Method"], "type": "ui"}, " to \"Average\", Houdini will calculate the hit based on an average point between the corners, giving a more\n    stable result with less jitter."]}, {"indent": 4, "type": "para", "extent": [6256, 6518], "text": ["This is similar to the effect of turning on ", {"text": ["Edge\n    representation"], "type": "ui"}, " in the ", {"text": ["Surface"], "type": "ui"}, " tab of an ", {"text": ["RBD\n    Object"], "fullpath": "/nodes/dop/rbdobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdobject"}, " node. If you have sparse geometry\n    with sharp edges, such as a cube, you may want to turn on both\n    these options."]}, {"indent": 4, "type": "para", "extent": [6518, 6729], "text": ["To see the effect of contact groupings, create a simulation\n    where you drop a cube onto a ground plane. Attach an ", {"text": ["RBD\n    Visualization DOP"], "fullpath": "/nodes/dop/rbdvisualization", "scheme": "Node", "type": "link", "value": "/nodes/dop/rbdvisualization"}, " to see the\n    resulting impacts."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [6739, 6856], "text": ["Calculate collisions for each point independently. Do not\n        attempt to merge similar collision points."]}], "indent": 4, "type": "dt", "extent": [6729, 6739], "text": ["None"]}, {"body": [{"indent": 8, "type": "para", "extent": [6880, 7114], "text": ["Group similar points together as the one point that is most\n        in-line with the center of mass of the object. This uses\n        only points from the original geometry and biases collision\n        points to stable points."]}], "indent": 4, "type": "dt", "extent": [6856, 6880], "text": ["Most central point"]}, {"body": [{"indent": 8, "type": "para", "extent": [7133, 7225], "text": ["Average similar points together to calculate the collision\n        point. "]}, {"indent": 8, "type": "para", "extent": [7225, 7404], "text": ["This reflects the geometry of the actual collision\n        better than \"Most central point\", but may result in a point\n        that does not lie on the original geometry."]}], "indent": 4, "type": "dt", "extent": [7114, 7133], "text": ["Average point"]}], "container": true, "type": "dt_group"}], "indent": 0, "type": "dt", "extent": [5345, 5370], "text": ["Contact Grouping Method"]}, {"body": [{"indent": 4, "type": "para", "extent": [7432, 7542], "text": ["The distance within which points are grouped together when\n    ", {"text": ["Contact grouping method"], "type": "ui"}, " is not \"none\"."]}], "indent": 0, "type": "dt", "extent": [7404, 7432], "text": ["Contact Grouping Tolerance"]}], "container": true, "type": "dt_group"}], "type": "root", "attrs": {"type": "include"}}